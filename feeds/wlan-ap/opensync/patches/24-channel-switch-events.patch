Index: opensync-2.0.5.0/interfaces/opensync_stats.proto
===================================================================
--- opensync-2.0.5.0.orig/interfaces/opensync_stats.proto
+++ opensync-2.0.5.0/interfaces/opensync_stats.proto
@@ -678,6 +678,12 @@ message VideoVoiceReport {
 	optional uint64 timestamp_ms = 7;
 }
 
+enum ChannelSwitchReason {
+        radar_detected                               = 0;
+        high_interference                            = 1;
+    }
+
+
 message EventReport {
     /* Client Association Event */
     message ClientAssocEvent {
@@ -782,6 +788,15 @@ message EventReport {
         optional uint64                 last_rcv_up_ts_in_us                = 5;
     }
 
+    /* Channel Switch Event */
+    message ChannelSwitchEvent {
+       required RadioBandType          band                                = 1;
+       required ChannelSwitchReason    reason                              = 2;
+	required uint32 		channel 			    = 3;
+	optional uint64         	timestamp_ms 			    = 4;
+    }
+
+
     /* Client Session */
     message ClientSession {
         required uint64                 session_id                          = 1;
@@ -798,6 +813,8 @@ message EventReport {
 
     /* Multiple Client Sessions */
     repeated ClientSession              client_session                      = 1;
+    repeated ChannelSwitchEvent         channel_switch                      = 2;
+
 }
 
 ////////////////////////////////////////////////////////////////////////////////
Index: opensync-2.0.5.0/src/lib/datapipeline/inc/dpp_events.h
===================================================================
--- opensync-2.0.5.0.orig/src/lib/datapipeline/inc/dpp_events.h
+++ opensync-2.0.5.0/src/lib/datapipeline/inc/dpp_events.h
@@ -40,6 +40,10 @@ typedef enum { CTR_IDLE_TOO_LONG = 0, CT
 /* proto: SecurityType */
 typedef enum { SEC_OPEN = 0, SEC_RADIUS, SEC_PSK } sec_type_t;
 
+/* proto: CSReason*/
+typedef enum { RADAR_DETECTED = 0, HIGH_INTERFERENCE} cs_reason_t;
+
+
 /* proto: ClientAssocEvent */
 typedef struct {
 	char __barrier[46];
@@ -178,6 +182,16 @@ typedef struct {
 	ds_dlist_node_t node;
 } dpp_event_record_timeout_t;
 
+/*proto: ChannelSwitchEvent*/
+typedef struct {
+       radio_type_t    band;
+       cs_reason_t     reason;
+       uint8_t         freq;
+       uint32_t        timestamp;
+
+       ds_dlist_node_t node;
+} dpp_event_record_channel_switch_t;
+
 /* proto: ClientSession */
 typedef struct {
 	uint64_t session_id;
@@ -197,6 +211,7 @@ typedef struct {
 /* event record */
 typedef struct {
 	ds_dlist_t client_session; /* dpp_event_record_session_t */
+        ds_dlist_t channel_switch; /* dpp_event_record_channel_switch_t*/
 
 	ds_dlist_node_t node;
 } dpp_event_record_t;
@@ -447,6 +462,32 @@ dpp_event_client_session_record_free(dpp
 	}
 }
 
+/*********************************/
+/* ChannelSwitch alloc/free */
+/*********************************/
+/* alloc */
+static inline dpp_event_record_channel_switch_t *
+dpp_event_channel_switch_record_alloc()
+{
+        dpp_event_record_channel_switch_t *record = NULL;
+
+        record = malloc(sizeof(dpp_event_record_channel_switch_t));
+        if (record) {
+                memset(record, 0, sizeof(dpp_event_record_channel_switch_t));
+        }
+        return record;
+}
+
+/* free */
+static inline void
+dpp_event_channel_switch_record_free(dpp_event_record_channel_switch_t *record)
+{
+        if (NULL != record) {
+                free(record);
+        }
+}
+
+
 /* Events report type */
 typedef struct {
 	ds_dlist_t list; /* dpp_event_record_t */
Index: opensync-2.0.5.0/src/lib/datapipeline/src/dppline.c
===================================================================
--- opensync-2.0.5.0.orig/src/lib/datapipeline/src/dppline.c
+++ opensync-2.0.5.0/src/lib/datapipeline/src/dppline.c
@@ -193,6 +193,9 @@ typedef struct {
 	dpp_event_record_timeout_t *timeout_list;
 	uint32_t timeout_qty;
 
+	dpp_event_record_channel_switch_t *chan_switch_list;
+	uint32_t chan_switch_qty;
+
 } dppline_event_rec_t;
 
 typedef struct dpp_events_stats {
@@ -276,11 +279,14 @@ static void dppline_free_stat(dppline_st
                 break;
             case DPP_T_UCC:
                 free(&s->u.ucc.record);
-                break;	case DPP_T_EVENTS:
-			free(s->u.events.list);
-			break;
+                break;	
+	    case DPP_T_EVENTS:
+		free(s->u.events.list);
+		
+		break;
+
+            default:
                 break;
-            default:;
         }
 
         free(s);
@@ -774,6 +780,9 @@ static bool dppline_copysts(dppline_stat
 		dpp_event_record_session_t *session = NULL;
 		ds_dlist_iter_t session_iter;
 
+                dpp_event_record_channel_switch_t *channel_switch = NULL;
+                ds_dlist_iter_t channel_switch_iter;
+
 		dpp_event_record_assoc_t *assoc = NULL;
 		ds_dlist_iter_t assoc_iter;
 		dpp_event_record_auth_t *auth = NULL;
@@ -1324,6 +1333,49 @@ static bool dppline_copysts(dppline_stat
 					.session_qty++;
 			}
 
+			// Add channel switch records
+			for (channel_switch = ds_dlist_ifirst(
+				     &channel_switch_iter,
+				     &result_entry->channel_switch);
+			     channel_switch != NULL;
+			     channel_switch = ds_dlist_inext(&channel_switch_iter)) {
+				size = (dst->u.events.list[dst->u.events.qty]
+						.chan_switch_qty +
+					1) *
+				       sizeof(dpp_event_record_channel_switch_t);
+
+				if (!dst->u.events.list[dst->u.events.qty]
+					     .chan_switch_qty) {
+					dst->u.events.list[dst->u.events.qty]
+						.chan_switch_list = calloc(1, size);
+				} else {
+					dst->u.events.list[dst->u.events.qty]
+						.chan_switch_list = realloc(
+						dst->u.events
+							.list[dst->u.events.qty]
+							.chan_switch_list,
+						size);
+					memset(&dst->u.events
+							.list[dst->u.events.qty]
+							.chan_switch_list
+								[dst->u.events
+									 .list[dst->u.events
+										       .qty]
+									 .chan_switch_qty],
+					       0,
+					       sizeof(dpp_event_record_channel_switch_t));
+				}
+				memcpy(&dst->u.events.list[dst->u.events.qty].chan_switch_list
+						[dst->u.events
+							 .list[dst->u.events.qty]
+							 .chan_switch_qty],
+				       channel_switch,
+				       sizeof(dpp_event_record_channel_switch_t));
+
+				dst->u.events.list[dst->u.events.qty]
+					.chan_switch_qty++;
+			}
+			
 			dst->u.events.qty++;
 		}
 	} break;
@@ -2973,6 +3025,7 @@ static void dppline_add_stat_events(Sts_
 {
 	Sts__EventReport *sr = NULL;
 	Sts__EventReport__ClientSession *dr_client_session = NULL;
+	Sts__EventReport__ChannelSwitchEvent *dr_channel_switch = NULL;
 	uint32_t i = 0;
 	uint32_t j = 0;
 	uint32_t k = 0;
@@ -3700,6 +3753,31 @@ static void dppline_add_stat_events(Sts_
 				}
 			}
 		}
+
+
+		/* channel switch Event */
+		sr->channel_switch = malloc(events->list[i].chan_switch_qty *
+						sizeof(*sr->channel_switch));
+		assert(sr->channel_switch);
+		sr->n_channel_switch = events->list[i].chan_switch_qty;
+
+		for (j = 0; j < events->list[i].chan_switch_qty; j++) {
+			dpp_event_record_channel_switch_t *sr_channel_switch =
+				&events->list[i].chan_switch_list[j];
+
+			dr_channel_switch = sr->channel_switch[j] =
+				malloc(sizeof(**sr->channel_switch));
+			sts__event_report__channel_switch_event__init(
+				dr_channel_switch);
+
+				dr_channel_switch->band = dppline_to_proto_radio(sr_channel_switch->band);
+				dr_channel_switch->reason = sr_channel_switch->reason;
+
+				dr_channel_switch->channel = sr_channel_switch->freq;
+
+				dr_channel_switch->timestamp_ms = sr_channel_switch->timestamp;
+				dr_channel_switch->timestamp_ms = true;
+		}
 	}
 }
 
