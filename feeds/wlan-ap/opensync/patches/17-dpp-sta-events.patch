Index: opensync-2.0.5.0/src/lib/datapipeline/src/dppline.c
===================================================================
--- opensync-2.0.5.0.orig/src/lib/datapipeline/src/dppline.c
+++ opensync-2.0.5.0/src/lib/datapipeline/src/dppline.c
@@ -43,6 +43,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #include "dpp_device.h"
 #include "dpp_capacity.h"
 #include "dpp_bs_client.h"
+#include "dpp_events.h"
 
 #ifndef TARGET_NATIVE
 #include "os_types.h"
@@ -64,6 +65,7 @@ typedef enum
     DPP_T_BS_CLIENT = 6,
     DPP_T_RSSI      = 7,
     DPP_T_NETWORK_PROBE =8,
+    DPP_T_EVENTS    = 9
 } DPP_STS_TYPE;
 
 uint32_t queue_depth;
@@ -96,6 +98,13 @@ typedef struct dpp_network_probe_stats
     uint64_t                        timestamp_ms;
 } dppline_network_probe_stats_t;
 
+typedef struct dpp_events_stats
+{
+    dpp_event_record_t             *list;
+    uint32_t                        qty;
+    uint64_t                        timestamp_ms;
+} dppline_events_stats_t;
+
 typedef struct
 {
     radio_type_t                    radio_type;
@@ -159,6 +168,8 @@ typedef struct dpp_rssi_stats
     uint64_t                        timestamp_ms;
 } dppline_rssi_stats_t;
 
+
+
 /* DPP stats type, used as element in internal double ds */
 typedef struct dpp_stats
 {
@@ -175,6 +186,7 @@ typedef struct dpp_stats
         dppline_bs_client_stats_t   bs_client;
         dppline_rssi_stats_t        rssi;
         dppline_network_probe_stats_t        network_probe;
+        dppline_events_stats_t       events;
     } u;
 } dppline_stats_t;
 
@@ -230,7 +242,13 @@ static void dppline_free_stat(dppline_st
                 break;
             case DPP_T_NETWORK_PROBE:
                 break;
-            default:;
+
+            case DPP_T_EVENTS:
+                free(s->u.events.list);
+                break;
+
+            default:
+                break;
         }
 
         free(s);
@@ -621,9 +639,43 @@ static bool dppline_copysts(dppline_stat
                 dpp_network_probe_report_data_t *report_data = sts;
                 memcpy(&dst->u.network_probe.record.dns_probe, &report_data->record.dns_probe, sizeof(dpp_dns_metrics_t));
                 memcpy(&dst->u.network_probe.record.vlan_probe, &report_data->record.vlan_probe, sizeof(dpp_vlan_metrics_t));
-		dst->u.network_probe.timestamp_ms = report_data->timestamp_ms;
+				dst->u.network_probe.timestamp_ms = report_data->timestamp_ms;
+           }
+           break;
+
+        case DPP_T_EVENTS:
+           {
+                dpp_event_report_data_t *report_data = sts;
+                dpp_event_record_t      *result_entry = NULL;
+                ds_dlist_iter_t          result_iter;
+
+                /* Loop through linked list of results and copy them to dppline buffer */
+                dst->u.events.qty = 0;
+                dst->u.events.timestamp_ms = report_data->timestamp_ms;
+                for (   result_entry = ds_dlist_ifirst(&result_iter, &report_data->list);
+                        result_entry != NULL;
+                        result_entry = ds_dlist_inext(&result_iter))
+                {
+                    size = (dst->u.events.qty + 1) * sizeof(dpp_event_record_t);
+                    if (!dst->u.events.qty) {
+                        dst->u.events.list = calloc(1, size);
+                    }
+                    else {
+                        dst->u.events.list = realloc(dst->u.events.list, size);
+                        memset(&dst->u.events.list[dst->u.events.qty],
+                               0,
+                               sizeof(dpp_event_record_t));
+                    }
+                    memcpy(&dst->u.events.list[dst->u.events.qty],
+                            result_entry,
+                            sizeof(dpp_event_record_t));
+
+                    dst->u.events.qty++;
+
+                }
            }
            break;
+
         default:
             LOG(ERR, "Failed to copy %d stats", dst->type);
             /* do nothing */
@@ -654,6 +706,103 @@ static char * getNodeid()
     return buff;
 }
 
+Sts__AssocType dppline_to_proto_assoc_type(assoc_type_t assoc_type)
+{
+    switch (assoc_type)
+    {
+        case AT_ASSOC:
+            return STS__ASSOC_TYPE__ASSOC;
+
+        case AT_REASSOC:
+            return STS__ASSOC_TYPE__REASSOC;
+
+        default:
+            assert(0);
+    }
+    return 0;
+}
+
+Sts__DeviceType dppline_to_proto_device_type(device_type_t device_type)
+{
+    switch (device_type)
+    {
+        case DT_AP:
+            return STS__DEVICE_TYPE__DEV_AP;
+
+        case DT_STA:
+            return STS__DEVICE_TYPE__DEV_STA;
+
+        default:
+            assert(0);
+    }
+    return 0;
+}
+
+Sts__FrameType dppline_to_proto_frame_type(frame_type_t frame_type)
+{
+    switch (frame_type)
+    {
+        case FT_DEAUTH:
+            return STS__FRAME_TYPE__FT_DEAUTH;
+
+        case FT_DISASSOC:
+            return STS__FRAME_TYPE__FT_DISASSOC;
+
+        default:
+            assert(0);
+    }
+    return 0;
+}
+
+Sts__CTReasonType dppline_to_proto_ct_reason_type(ct_reason_t reason_type)
+{
+    switch (reason_type)
+    {
+        case CTR_IDLE_TOO_LONG:
+            return STS__CTREASON_TYPE__CTR_IDLE_TOO_LONG;
+
+        case CTR_PROBE_FAIL:
+            return STS__CTREASON_TYPE__CTR_PROBE_FAIL;
+
+        default:
+            assert(0);
+    }
+    return 0;
+}
+
+Sts__EventType dppline_to_proto_event_type(event_type_t event_type)
+{
+    switch (event_type)
+    {
+        case ET_CLIENT_ASSOC:
+            return STS__EVENT_TYPE__CLIENT_ASSOC;
+
+        case ET_CLIENT_AUTH:
+            return STS__EVENT_TYPE__CLIENT_AUTH;
+
+        case ET_CLIENT_DISCONNECT:
+            return STS__EVENT_TYPE__CLIENT_DISCONNECT;
+
+        case ET_CLIENT_FAILURE:
+            return STS__EVENT_TYPE__CLIENT_FAILURE;
+
+        case ET_CLIENT_FIRST_DATA:
+            return STS__EVENT_TYPE__CLIENT_FIRST_DATA;
+
+        case ET_CLIENT_ID:
+            return STS__EVENT_TYPE__CLIENT_ID;
+
+        case ET_CLIENT_IP:
+            return STS__EVENT_TYPE__CLIENT_IP;
+
+        case ET_CLIENT_TIMEOUT:
+            return STS__EVENT_TYPE__CLIENT_TIMEOUT;
+
+        default:
+            assert(0);
+    }
+    return 0;
+}
 
 Sts__RadioBandType dppline_to_proto_radio(radio_type_t radio_type)
 {
@@ -1239,6 +1388,87 @@ static void dppline_add_stat_client(Sts_
             sizeof(*s->u.device), s->size, size);*/
 }
 
+static void dppline_add_stat_events(Sts__Report *r, dppline_stats_t *s)
+{
+    Sts__EventReport *sr = NULL;
+    Sts__EventReport__ClientAssocEvent *dr_assoc = NULL;
+    Sts__EventReport__ClientAuthEvent *dr_auth = NULL;
+    Sts__EventReport__ClientDisconnectEvent *dr_dscn = NULL;
+    /*
+    Sts__EventReport__ClientFailureEvent *dr_fail;
+    Sts__EventReport__ClientFirstDataEvent *dr_fdata;
+    Sts__EventReport__ClientIdEvent *dr_id;
+    Sts__EventReport__ClientIpEvent *dr_ip;
+    Sts__EventReport__ClientTimeoutEvent *dr_tmt;
+    */
+    uint32_t i = 0;
+    //int j;
+    int size = 0;
+    dppline_events_stats_t *events = &s->u.events;
+
+    // increase the number of event_report
+    r->n_event_report++;
+
+    // allocate or extend the size of event_report
+    r->event_report = realloc(r->event_report,
+                              r->n_event_report * sizeof(Sts__EventReport*));
+
+    // allocate new buffer
+    sr = malloc(sizeof(Sts__EventReport));
+    size += sizeof(Sts__EventReport);
+    assert(sr);
+    r->event_report[r->n_event_report - 1] = sr;
+    sts__event_report__init(sr);
+    //sr->timestamp_ms = events->timestamp_ms;
+
+    for (i = 0; i < events->qty; i++)
+    {
+        // dpp event pointer
+        dpp_event_record_t *rec = &events->list[i];
+
+        // ClientAssocEvent
+        if(rec->event_type == ET_CLIENT_ASSOC){
+            // init
+            sts__event_report__client_assoc_event__init(dr_assoc);
+            // STA mac
+            dr_assoc->sta_mac = malloc(MACADDR_STR_LEN);
+            dpp_mac_to_str(rec->client_assoc_event.sta_mac, dr_assoc->sta_mac);
+            // SSID
+            if(rec->client_assoc_event.ssid)
+                dr_assoc->ssid = strcpy(dr_assoc->ssid, rec->client_assoc_event.ssid);
+            // session id
+            dr_assoc->session_id = rec->client_assoc_event.session_id;
+
+        // ClientAuthEvent
+        }else if (rec->event_type == ET_CLIENT_AUTH){
+            // init
+            sts__event_report__client_auth_event__init(dr_auth);
+            // STA mac
+            dr_auth->sta_mac = malloc(MACADDR_STR_LEN);
+            dpp_mac_to_str(rec->client_auth_event.sta_mac, dr_auth->sta_mac);
+            // SSID
+            if(rec->client_auth_event.ssid)
+                dr_auth->ssid = strcpy(dr_auth->ssid, rec->client_auth_event.ssid);
+            // session id
+            dr_auth->session_id = rec->client_auth_event.session_id;
+
+        // ClientDisconnectEvent
+        }else if (rec->event_type == ET_CLIENT_DISCONNECT){
+            // init
+            sts__event_report__client_disconnect_event__init(dr_dscn);
+            // STA mac
+            dr_dscn->sta_mac = malloc(MACADDR_STR_LEN);
+            dpp_mac_to_str(rec->client_disconnect_event.sta_mac, dr_dscn->sta_mac);
+            // SSID
+            if(rec->client_disconnect_event.ssid)
+                dr_dscn->ssid = strcpy(dr_dscn->ssid, rec->client_disconnect_event.ssid);
+            // session id
+            dr_dscn->session_id = rec->client_disconnect_event.session_id;
+
+        }
+    }
+}
+
 static void dppline_add_stat_device(Sts__Report *r, dppline_stats_t *s)
 {
     Sts__Device *sr = NULL;
@@ -1954,6 +2184,10 @@ static void dppline_add_stat(Sts__Report
             dppline_add_stat_network_probe(r, s);
             break;
 
+        case DPP_T_EVENTS:
+            dppline_add_stat_events(r, s);
+            break;
+
         default:
             LOG(ERR, "Failed to add %d to stats report", s->type);
             /* do nothing       */
@@ -2118,6 +2352,14 @@ bool dpp_put_network_probe(dpp_network_p
 }
 
 /*
+ * Put event report to internal queue
+ */
+bool dpp_put_events(dpp_event_report_data_t *rpt)
+{
+    return dppline_put(DPP_T_EVENTS, rpt);
+}
+
+/*
  * Create the protobuf buff and copy it to given buffer
  */
 #ifndef DPP_FAST_PACK
Index: opensync-2.0.5.0/platform/openwrt/src/lib/target/inc/target_OPENWRT.h
===================================================================
--- opensync-2.0.5.0.orig/platform/openwrt/src/lib/target/inc/target_OPENWRT.h
+++ opensync-2.0.5.0/platform/openwrt/src/lib/target/inc/target_OPENWRT.h
@@ -25,10 +25,11 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 */
 
 #ifndef TARGET_OPENWRT_H_INCLUDED
-#define TARGET_OPEMWRT_H_INCLUDED
+#define TARGET_OPENWRT_H_INCLUDED
 
 #include "dpp_client.h"
 #include "dpp_survey.h"
+#include "dpp_events.h"
 
 #define TARGET_CERT_PATH            "/var/run/openvswitch/certs"
 #define TARGET_MANAGERS_PID_PATH    "/tmp/dmpid"
@@ -54,6 +55,12 @@ typedef struct
 	uint32_t duration_ms;
 } target_survey_record_t;
 
+typedef struct
+{
+        dpp_event_record_t record;
+
+} target_event_record_t;
+
 typedef void target_capacity_data_t;
 
 /******************************************************************************
Index: opensync-2.0.5.0/platform/openwrt/src/lib/target/src/stats.c
===================================================================
--- opensync-2.0.5.0.orig/platform/openwrt/src/lib/target/src/stats.c
+++ opensync-2.0.5.0/platform/openwrt/src/lib/target/src/stats.c
@@ -67,6 +67,43 @@ bool target_radio_fast_scan_enable(radio
 	return true;
 }
 
+/******************************************************************************
+ *  EVENT definitions
+ *****************************************************************************/
+target_event_record_t* target_event_record_alloc()
+{
+	target_event_record_t *record = NULL;
+
+	record = malloc(sizeof(target_event_record_t));
+	if (record == NULL)
+		return NULL;
+
+	memset(record, 0, sizeof(target_event_record_t));
+
+	return record;
+}
+
+void target_event_record_free(target_event_record_t *record)
+{
+	if (record != NULL)
+		free(record);
+}
+
+bool target_stats_events_get(radio_entry_t *radio_cfg,
+                             ds_dlist_t *record_list)
+{
+	struct nl_call_param nl_call_param = {
+		.ifname = radio_cfg->if_name,
+		.type = radio_cfg->type,
+                .list = record_list
+	};
+	bool ret = true;
+	if (nl80211_rt_events_handler(&nl_call_param) < 0)
+		ret = false;
+
+        return ret;
+}
+
 
 /******************************************************************************
  *  CLIENT definitions
Index: opensync-2.0.5.0/platform/openwrt/src/lib/target/src/stats_nl80211.c
===================================================================
--- opensync-2.0.5.0.orig/platform/openwrt/src/lib/target/src/stats_nl80211.c
+++ opensync-2.0.5.0/platform/openwrt/src/lib/target/src/stats_nl80211.c
@@ -48,6 +48,7 @@ struct nl80211_scan {
 	struct avl_node avl;
 	ev_async async;
 };
+extern struct rt_events g_rt_events;
 
 static struct avl_tree nl80211_scan_tree = AVL_TREE_INIT(nl80211_scan_tree, avl_strcmp, false, NULL);
 
@@ -452,6 +453,9 @@ static struct nl_msg *nl80211_call_vif(s
 
 	if (!nl80211_scan_started) {
 		unl_genl_subscribe(&unl, "scan");
+		unl_genl_subscribe(&unl, "mlme");
+		unl_genl_subscribe(&unl, "vendor");
+		unl_genl_subscribe(&unl, "config");
 
 		ev_io_init(&unl_io, nl80211_ev, unl.sock->s_fd, EV_READ);
 		ev_io_start(wifihal_evloop, &unl_io);
@@ -555,6 +559,26 @@ int nl80211_scan_dump(struct nl_call_par
 	return unl_genl_request(&unl, msg, nl80211_scan_dump_recv, nl_call_param);
 }
 
+int nl80211_rt_events_handler(struct nl_call_param *nl_call_param)
+{
+        if(ds_dlist_is_empty(&g_rt_events.event_list)) return -1;
+
+        target_event_record_t  *target_record = NULL;
+        ds_dlist_iter_t         record_iter;
+        /* get cached eventes */
+        for (target_record = ds_dlist_ifirst(&record_iter, &g_rt_events.event_list);
+             target_record != NULL;
+             target_record = ds_dlist_inext(&record_iter))
+        {
+            // copy (shallow)
+	    ds_dlist_insert_tail(nl_call_param->list, target_record);
+            // remove
+            ds_dlist_iremove(&record_iter);
+        }
+        // no error
+        return 0;
+}
+
 int stats_nl80211_init(void)
 {
 	if (unl_genl_init(&unl, "nl80211") < 0) {
Index: opensync-2.0.5.0/src/lib/datapipeline/inc/dppline.h
===================================================================
--- opensync-2.0.5.0.orig/src/lib/datapipeline/inc/dppline.h
+++ opensync-2.0.5.0/src/lib/datapipeline/inc/dppline.h
@@ -46,6 +46,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #include "dpp_bs_client.h"
 #include "dpp_rssi.h"
 #include "dpp_network_probe.h"
+#include "dpp_events.h"
 
 #ifdef CONFIG_MANAGER_QM
 // QM does queue-ing of reports when offline on it's own, so dpp needs
@@ -107,6 +108,11 @@ bool dpp_put_bs_client(dpp_bs_client_rep
 bool dpp_put_rssi(dpp_rssi_report_data_t *rpt);
 
 /*
+ * Put event report to internal queue
+ */
+bool dpp_put_events(dpp_event_report_data_t *rpt);
+
+/*
  * Get the protobuf packed buffer
  *
  * This buffer is ready to be send using MQTT
Index: opensync-2.0.5.0/src/sm/src/sm_ovsdb.c
===================================================================
--- opensync-2.0.5.0.orig/src/sm/src/sm_ovsdb.c
+++ opensync-2.0.5.0/src/sm/src/sm_ovsdb.c
@@ -62,6 +62,7 @@ char *sm_report_type_str[STS_REPORT_MAX]
     "device",
     "rssi",
     "network_probe",
+    "event",
 };
 
 #ifndef CONFIG_MANAGER_QM
@@ -359,8 +360,11 @@ bool sm_update_stats_config(sm_stats_con
             sm_rssi_report_request(&radio->config, &req);
             break;
 	case STS_REPORT_NETWORK_PROBE:
-	sm_network_probe_report_request(&req);
-	break;
+	    sm_network_probe_report_request(&req);
+	    break;
+        case STS_REPORT_EVENT:
+            sm_events_report_request(&radio->config, &req);
+            break;
         default:
             return false;
     }
Index: opensync-2.0.5.0/src/lib/target/inc/target_native.h
===================================================================
--- opensync-2.0.5.0.orig/src/lib/target/inc/target_native.h
+++ opensync-2.0.5.0/src/lib/target/inc/target_native.h
@@ -39,6 +39,8 @@ typedef void target_survey_record_t;
 
 typedef void target_capacity_data_t;
 
+typedef void target_event_record_t;
+
 #include "target_common.h"
 
 #endif  /* TARGET_NATIVE_H_INCLUDED */
Index: opensync-2.0.5.0/vendor/tip/src/lib/target/inc/target_tip.h
===================================================================
--- opensync-2.0.5.0.orig/vendor/tip/src/lib/target/inc/target_tip.h
+++ opensync-2.0.5.0/vendor/tip/src/lib/target/inc/target_tip.h
@@ -29,6 +29,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 
 #include "dpp_client.h"
 #include "dpp_survey.h"
+#include "dpp_events.h"
 
 #define TARGET_CERT_PATH            "/var/run/openvswitch/certs"
 #define TARGET_MANAGERS_PID_PATH    "/tmp/dmpid"
@@ -54,6 +55,12 @@ typedef struct
 	uint32_t duration_ms;
 } target_survey_record_t;
 
+typedef struct
+{
+        dpp_event_record_t record;
+
+} target_event_record_t;
+
 typedef void target_capacity_data_t;
 
 /******************************************************************************
Index: opensync-2.0.5.0/src/lib/target/inc/target_common.h
===================================================================
--- opensync-2.0.5.0.orig/src/lib/target/inc/target_common.h
+++ opensync-2.0.5.0/src/lib/target/inc/target_common.h
@@ -389,6 +389,13 @@ typedef bool target_stats_clients_cb_t (
         void                       *ctx,
         int                         status);
 
+/******************************************************************************
+ *  EVENT definitions
+ *****************************************************************************/
+target_event_record_t *target_event_record_alloc();
+bool target_stats_events_get(radio_entry_t *radio_cfg,
+                             ds_dlist_t *record_list);
+
 /**
  * @brief Get clients stats
  *
Index: opensync-2.0.5.0/src/sm/src/sm.h
===================================================================
--- opensync-2.0.5.0.orig/src/sm/src/sm.h
+++ opensync-2.0.5.0/src/sm/src/sm.h
@@ -161,6 +161,13 @@ bool sm_network_probe_report_request(
         sm_stats_request_t         *request);
 
 /******************************************************************************
+ *  EVENTS REPORT definitions
+ *****************************************************************************/
+bool sm_events_report_request(
+        radio_entry_t              *radio_cfg,
+        sm_stats_request_t         *request);
+
+/******************************************************************************
  *  SURVEY_REPORT definitions
  *****************************************************************************/
 bool sm_survey_report_request(
@@ -271,6 +278,7 @@ typedef enum
     STS_REPORT_DEVICE,
     STS_REPORT_RSSI,
     STS_REPORT_NETWORK_PROBE,
+    STS_REPORT_EVENT,
     STS_REPORT_MAX,
     STS_REPORT_ERROR = STS_REPORT_MAX
 } sm_report_type_t;
Index: opensync-2.0.5.0/src/sm/unit.mk
===================================================================
--- opensync-2.0.5.0.orig/src/sm/unit.mk
+++ opensync-2.0.5.0/src/sm/unit.mk
@@ -43,6 +43,7 @@ UNIT_SRC     += src/sm_survey_report.c
 UNIT_SRC     += src/sm_radio_config.c
 UNIT_SRC     += src/sm_scan_schedule.c
 UNIT_SRC     += src/sm_rssi_report.c
+UNIT_SRC     += src/sm_events_report.c
 UNIT_SRC     += src/sm_network_probe_report.c
 UNIT_SRC     += src/sm_common.c
 
Index: opensync-2.0.5.0/platform/openwrt/src/lib/target/inc/nl80211.h
===================================================================
--- opensync-2.0.5.0.orig/platform/openwrt/src/lib/target/inc/nl80211.h
+++ opensync-2.0.5.0/platform/openwrt/src/lib/target/inc/nl80211.h
@@ -5,6 +5,8 @@
 
 #include <net/if.h>
 
+#include <sys/types.h>
+
 #include <linux/limits.h>
 
 #include <libubox/avl.h>
@@ -53,6 +55,8 @@ struct wifi_station {
 	uint32_t rx_bytes;
 	uint32_t tx_bytes;
 };
+struct nl_msg;
+struct nlattr;
 
 extern int radio_nl80211_init(void);
 
@@ -66,6 +70,11 @@ struct nl_call_param {
 	ds_dlist_t *list;
 };
 
+struct rt_events {
+    ds_dlist_t event_list;
+};
+
+
 typedef struct ssid_list {
         char ssid[RADIO_ESSID_LEN+1];
         char ifname[RADIO_NAME_LEN+1];
@@ -75,12 +84,14 @@ typedef struct ssid_list {
 extern int stats_nl80211_init(void);
 extern int nl80211_get_tx_chainmask(char *name, unsigned int *mask);
 extern int nl80211_get_assoclist(struct nl_call_param *nl_call_param);
+extern int nl80211_get_sta_assoc(struct nl_call_param *nl_call_param);
 extern int nl80211_get_survey(struct nl_call_param *nl_call_param);
 extern int nl80211_scan_trigger(struct nl_call_param *nl_call_param, uint32_t *chan_list, uint32_t chan_num,
 				int dwell_time, radio_scan_type_t scan_type,
 				target_scan_cb_t *scan_cb, void *scan_ctx);
 extern int nl80211_scan_abort(struct nl_call_param *nl_call_param);
 extern int nl80211_scan_dump(struct nl_call_param *nl_call_param);
+extern int nl80211_rt_events_handler(struct nl_call_param *nl_call_param);
 extern int nl80211_get_ssid(struct nl_call_param *nl_call_param);
 
 #endif
Index: opensync-2.0.5.0/platform/openwrt/src/lib/target/src/radio_nl80211.c
===================================================================
--- opensync-2.0.5.0.orig/platform/openwrt/src/lib/target/src/radio_nl80211.c
+++ opensync-2.0.5.0/platform/openwrt/src/lib/target/src/radio_nl80211.c
@@ -12,6 +12,7 @@
 #include <net/if.h>
 
 #include <sys/types.h>
+#include <linux/types.h>
 
 #include <linux/sockios.h>
 #include <linux/nl80211.h>
@@ -40,6 +41,7 @@
 extern struct ev_loop *wifihal_evloop;
 static struct unl unl;
 static ev_io unl_io;
+struct rt_events g_rt_events;
 
 static int avl_addrcmp(const void *k1, const void *k2, void *ptr)
 {
@@ -387,6 +389,108 @@ static void nl80211_del_phy(struct nlatt
 	free(phy);
 }
 
+
+static void mlme_ev_auth(struct nl_msg *msg, struct nlattr **tb)
+{
+    /* check ssid and mac */
+    struct nlattr *ssid = tb[NL80211_ATTR_SSID];
+    struct nlattr *mac = tb[NL80211_ATTR_MAC];
+    if(!(ssid && mac)) return;
+
+    /* add to list */
+    target_event_record_t *event_entry = target_event_record_alloc();
+    event_entry->record.event_type = ET_CLIENT_AUTH;
+    /* client_auth event pointer */
+    dpp_event_record_auth_t *cap = &event_entry->record.client_auth_event;
+    memset(cap, 0, sizeof(dpp_event_record_auth_t));
+    /* set data */
+    memcpy(cap->sta_mac, nla_data(mac), ETH_ALEN);
+    memcpy(cap->ssid, nla_data(ssid), nla_len(ssid));
+    cap->session_id = get_timestamp();
+    /* add to global list */
+    ds_dlist_insert_tail(&g_rt_events.event_list, event_entry);
+}
+
+static void mlme_ev_assoc(struct nl_msg *msg, struct nlattr **tb)
+{
+    /* check ssid and mac */
+    struct nlattr *ssid = tb[NL80211_ATTR_SSID];
+    struct nlattr *mac = tb[NL80211_ATTR_MAC];
+    if(!(ssid && mac)) return;
+
+    /* add to list */
+    target_event_record_t *event_entry = target_event_record_alloc();
+    event_entry->record.event_type = ET_CLIENT_ASSOC;
+    /* client_auth event pointer */
+    dpp_event_record_assoc_t *cap = &event_entry->record.client_assoc_event;
+    memset(cap, 0, sizeof(dpp_event_record_assoc_t));
+    /* set data */
+    memcpy(cap->sta_mac, nla_data(mac), ETH_ALEN);
+    memcpy(cap->ssid, nla_data(ssid), nla_len(ssid));
+    cap->session_id = get_timestamp();
+    /* add to global list */
+    ds_dlist_insert_tail(&g_rt_events.event_list, event_entry);
+}
+
+static void mlme_ev_disconnect(struct nl_msg *msg, struct nlattr **tb)
+{
+	/* check ssid and mac */
+	struct nlattr *ssid = tb[NL80211_ATTR_SSID];
+	struct nlattr *mac = tb[NL80211_ATTR_MAC];
+	if (!(ssid && mac))
+		return;
+
+	/* add to list */
+	target_event_record_t *event_entry = target_event_record_alloc();
+	event_entry->record.event_type = ET_CLIENT_DISCONNECT;
+	/* client_auth event pointer */
+	dpp_event_record_disconnect_t *cap =
+		&event_entry->record.client_disconnect_event;
+	memset(cap, 0, sizeof(dpp_event_record_disconnect_t));
+	/* set data */
+	memcpy(cap->sta_mac, nla_data(mac), ETH_ALEN);
+	memcpy(cap->ssid, nla_data(ssid), nla_len(ssid));
+	cap->session_id = get_timestamp();
+	/* add to global list */
+	ds_dlist_insert_tail(&g_rt_events.event_list, event_entry);
+}
+
+
+
+static void mlme_ev_recv(struct nl_msg *msg, struct nlattr **tb)
+{
+	size_t len;
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct nlattr *frame = tb[NL80211_ATTR_FRAME];
+	struct nlattr *addr = tb[NL80211_ATTR_MAC];
+
+	/* frame should be present */
+	if (!(frame && addr))
+		return;
+
+	/*data = nla_data(frame); */
+	len = nla_len(frame);
+
+	/* length check */
+	if (len < 4 + 2 * ETH_ALEN)
+		return;
+
+	switch (gnlh->cmd) {
+	case NL80211_CMD_AUTHENTICATE:
+		mlme_ev_auth(msg, tb);
+		break;
+	case NL80211_CMD_ASSOCIATE:
+		mlme_ev_assoc(msg, tb);
+		break;
+	case NL80211_CMD_DEAUTHENTICATE:
+	case NL80211_CMD_DISASSOCIATE:
+	case NL80211_CMD_UNPROT_DEAUTHENTICATE:
+	case NL80211_CMD_UNPROT_DISASSOCIATE:
+		mlme_ev_disconnect(msg, tb);
+		break;
+	}
+}
+
 static int nl80211_recv(struct nl_msg *msg, void *arg)
 {
 	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
@@ -436,6 +540,21 @@ static int nl80211_recv(struct nl_msg *m
 	case NL80211_CMD_GET_WIPHY:
 		nl80211_add_phy(tb, phyname);
 		break;
+	/* connect */
+	case NL80211_CMD_ASSOCIATE:
+	case NL80211_CMD_AUTHENTICATE:
+	case NL80211_CMD_DEAUTHENTICATE:
+	case NL80211_CMD_DISASSOCIATE:
+	case NL80211_CMD_CONNECT:
+		mlme_ev_recv(msg, tb);
+		break;
+	/* disconnect */
+	case NL80211_CMD_DISCONNECT:
+	case NL80211_CMD_UNPROT_DEAUTHENTICATE:
+	case NL80211_CMD_UNPROT_DISASSOCIATE:
+		mlme_ev_disconnect(msg, tb);
+		break;
+
 	default:
 		syslog(0, "%s:%s[%d]%d\n", __FILE__, __func__, __LINE__, gnlh->cmd);
 		break;
@@ -495,6 +614,9 @@ int radio_nl80211_init(void)
 		return -1;
 	}
 
+	/* init global real time event list */
+	ds_dlist_init(&g_rt_events.event_list, dpp_event_record_t, node);
+
 	msg = unl_genl_msg(&unl, NL80211_CMD_GET_WIPHY, true);
 	unl_genl_request(&unl, msg, nl80211_recv, NULL);
 	msg = unl_genl_msg(&unl, NL80211_CMD_GET_INTERFACE, true);
@@ -505,7 +627,7 @@ int radio_nl80211_init(void)
 	unl_genl_subscribe(&unl, "vendor");
 
 	ev_io_init(&unl_io, nl80211_ev, unl.sock->s_fd, EV_READ);
-        ev_io_start(wifihal_evloop, &unl_io);
+	ev_io_start(wifihal_evloop, &unl_io);
 	evsched_task(&vif_poll_stations, NULL, EVSCHED_SEC(5));
 
 	return 0;
Index: opensync-2.0.5.0/platform/openwrt/src/lib/target/src/radio.c
===================================================================
--- opensync-2.0.5.0.orig/platform/openwrt/src/lib/target/src/radio.c
+++ opensync-2.0.5.0/platform/openwrt/src/lib/target/src/radio.c
@@ -14,7 +14,6 @@
 #include "ovsdb_table.h"
 #include "ovsdb_cache.h"
 
-#include "nl80211.h"
 #include "radio.h"
 #include "vif.h"
 #include "phy.h"
@@ -22,6 +21,7 @@
 #include "evsched.h"
 #include "uci.h"
 #include "utils.h"
+#include "nl80211.h"
 
 static struct uci_package *wireless;
 struct uci_context *uci;
Index: opensync-2.0.5.0/platform/openwrt/src/lib/target/override.mk
===================================================================
--- opensync-2.0.5.0.orig/platform/openwrt/src/lib/target/override.mk
+++ opensync-2.0.5.0/platform/openwrt/src/lib/target/override.mk
@@ -61,4 +61,5 @@ UNIT_DEPS += src/lib/evsched
 UNIT_LDFLAGS += -luci
 UNIT_LDFLAGS += -libiwinfo
 UNIT_LDFLAGS += -libnl-tiny
+UNIT_LDFLAGS += -lcurl
 UNIT_DEPS_CFLAGS += src/lib/inet
Index: opensync-2.0.5.0/src/wm2/tests/unit.mk
===================================================================
--- opensync-2.0.5.0.orig/src/wm2/tests/unit.mk
+++ opensync-2.0.5.0/src/wm2/tests/unit.mk
@@ -34,4 +34,4 @@ UNIT_DEPS += src/lib/osa
 UNIT_DEPS += src/lib/schema
 UNIT_DEPS += src/lib/ovsdb
 UNIT_LDFLAGS += -luci
-UNIT_LDFLAGS += -lnl-tiny -lubox -lubus -lblobmsg_json
+UNIT_LDFLAGS += -lnl-tiny -lubox -lubus -lblobmsg_json -lcurl
Index: opensync-2.0.5.0/src/wm2/unit.mk
===================================================================
--- opensync-2.0.5.0.orig/src/wm2/unit.mk
+++ opensync-2.0.5.0/src/wm2/unit.mk
@@ -47,7 +47,7 @@ UNIT_LDFLAGS += -ldl
 UNIT_LDFLAGS += -lev
 UNIT_LDFLAGS += -lrt
 UNIT_LDFLAGS += -luci
-UNIT_LDFLAGS += -lnl-tiny -lubox -lubus -lblobmsg_json
+UNIT_LDFLAGS += -lnl-tiny -lubox -lubus -lblobmsg_json -lcurl
 
 UNIT_EXPORT_CFLAGS := $(UNIT_CFLAGS)
 UNIT_EXPORT_LDFLAGS := $(UNIT_LDFLAGS)
Index: opensync-2.0.5.0/interfaces/opensync_stats.proto
===================================================================
--- opensync-2.0.5.0.orig/interfaces/opensync_stats.proto
+++ opensync-2.0.5.0/interfaces/opensync_stats.proto
@@ -591,23 +591,23 @@ message EventReport {
 
     // Client Authentication Event
     message ClientAuthEvent {
-        optional bytes staMac                  = 1;
-        optional uint64 sessionId              = 2;
+        optional string sta_mac                = 1;
+        optional uint64 session_id             = 2;
         optional string ssid                   = 3;
         optional RadioBandType band            = 4;
-        optional uint32 authStatus             = 5;
+        optional uint32 auth_status            = 5;
     }
 
     // Client Disconnect Event
     message ClientDisconnectEvent {
-        optional bytes staMac                  = 1;
-        optional uint64 sessionId              = 2;
+        optional string sta_mac                = 1;
+        optional uint64 session_id             = 2;
         optional uint32 reason                 = 3;
         optional DeviceType dev_type           = 4;
-        optional FrameType frType              = 5;
-        optional uint64 lastSentUpTsInUs       = 6;
-        optional uint64 lastRcvUpTsInUs        = 7;
-        optional uint32 internalRC             = 8;
+        optional FrameType fr_type             = 5;
+        optional uint64 lsent_up_ts_in_us      = 6;
+        optional uint64 lrcv_up_ts_in_us       = 7;
+        optional uint32 internal_rc            = 8;
         optional int32 rssi                    = 9;
         optional string ssid                   = 10;
         optional RadioBandType band            = 11;
@@ -615,44 +615,44 @@ message EventReport {
 
     // Client Failure Event
     message ClientFailureEvent {
-        optional bytes staMac                  = 1;
-        optional uint64 sessionId              = 2;
+        optional string sta_mac                = 1;
+        optional uint64 session_id             = 2;
         optional string ssid                   = 3;
-        optional int32  reasonCode             = 4;
-        optional string reasonStr              = 5;
+        optional int32  reason_code            = 4;
+        optional string reason_str             = 5;
     }
 
 
     // Client First Data Event
     message ClientFirstDataEvent {
-        optional bytes staMac                  = 1;
-        optional uint64 sessionId              = 2;
-        optional uint64 firstDataTxedUpTsInUs  = 3;
-        optional uint64 firstDataRxedUpTsInUs  = 4;
+        optional string sta_mac                = 1;
+        optional uint64 session_id             = 2;
+        optional uint64 fdata_tx_up_ts_in_us   = 3;
+        optional uint64 fdata_rx_up_ts_in_us   = 4;
     }
 
 
     // Client Id Event
     message ClientIdEvent {
-        optional bytes cltMac                  = 1;
-        optional uint64 sessionId              = 2;
-        optional string cltId                  = 3;
+        optional string clt_mac                = 1;
+        optional uint64 session_id             = 2;
+        optional string clt_id                 = 3;
     }
 
     // Client IP Event
     message ClientIpEvent {
-        optional bytes staMac                  = 1;
-        optional uint64 sessionId              = 2;
-        optional bytes ipAddr                  = 3;
+        optional string sta_mac                = 1;
+        optional uint64 session_id             = 2;
+        optional bytes ip_addr                 = 3;
     }
 
     // Client Timeout Event
     message ClientTimeoutEvent {
-        optional bytes staMac                  = 1;
-        optional uint64 sessionId              = 2;
-        optional CTReasonType rCode            = 3;
-        optional uint64 lastSentUpTsInUs       = 4;
-        optional uint64 lastRcvUpTsInUs        = 5;
+        optional string sta_mac                = 1;
+        optional uint64 session_id             = 2;
+        optional CTReasonType r_code           = 3;
+        optional uint64 last_sent_up_ts_in_us  = 4;
+        optional uint64 last_rcv_up_ts_in_us   = 5;
     }
 
     required EventType event_type                          = 1;
Index: opensync-2.0.5.0/platform/openwrt/src/rrm/unit.mk
===================================================================
--- opensync-2.0.5.0.orig/platform/openwrt/src/rrm/unit.mk
+++ opensync-2.0.5.0/platform/openwrt/src/rrm/unit.mk
@@ -16,7 +16,7 @@ UNIT_CFLAGS := -I$(UNIT_PATH)/inc
 UNIT_CFLAGS += -Isrc/lib/common/inc/
 UNIT_CFLAGS += -Isrc/lib/version/inc/
 
-UNIT_LDFLAGS := -lev -lubus -lubox -luci -lblobmsg_json -lnl-tiny
+UNIT_LDFLAGS := -lev -lubus -lubox -luci -lblobmsg_json -lnl-tiny -lcurl
 UNIT_LDFLAGS += -lrt
 
 UNIT_EXPORT_CFLAGS := $(UNIT_CFLAGS)
Index: opensync-2.0.5.0/platform/openwrt/src/netifd/unit.mk
===================================================================
--- opensync-2.0.5.0.orig/platform/openwrt/src/netifd/unit.mk
+++ opensync-2.0.5.0/platform/openwrt/src/netifd/unit.mk
@@ -14,7 +14,7 @@ UNIT_CFLAGS := -I$(UNIT_PATH)/inc
 UNIT_CFLAGS += -Isrc/lib/common/inc/
 UNIT_CFLAGS += -Isrc/lib/version/inc/
 
-UNIT_LDFLAGS += -lev -lubus -lubox -luci -lblobmsg_json -lnl-tiny
+UNIT_LDFLAGS += -lev -lubus -lubox -luci -lblobmsg_json -lnl-tiny -lcurl
 UNIT_LDFLAGS += -lrt
 
 UNIT_EXPORT_CFLAGS := $(UNIT_CFLAGS)
