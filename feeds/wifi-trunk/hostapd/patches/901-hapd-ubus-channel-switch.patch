Index: hostapd-2020-06-08-5a8b3662/src/ap/dfs.c
===================================================================
--- hostapd-2020-06-08-5a8b3662.orig/src/ap/dfs.c
+++ hostapd-2020-06-08-5a8b3662/src/ap/dfs.c
@@ -18,7 +18,7 @@
 #include "drivers/driver.h"
 #include "dfs.h"
 #include "crypto/crypto.h"
-
+#include "ubus.h"
 
 static int dfs_get_used_n_chans(struct hostapd_iface *iface, int *seg1)
 {
@@ -1171,6 +1171,7 @@ static int hostapd_dfs_start_channel_swi
 	/* Channel configuration will be updated once CSA completes and
 	 * ch_switch_notify event is received */
 
+	hostapd_ubus_handle_channel_switch_event(iface, HOSTAPD_UBUS_DFS_SWITCH,  channel->freq);
 	wpa_printf(MSG_DEBUG, "DFS waiting channel switch event");
 	return 0;
 }
Index: hostapd-2020-06-08-5a8b3662/src/ap/ubus.c
===================================================================
--- hostapd-2020-06-08-5a8b3662.orig/src/ap/ubus.c
+++ hostapd-2020-06-08-5a8b3662/src/ap/ubus.c
@@ -29,6 +29,8 @@ static int ctx_ref;
 static char** bss_lst = NULL;
 static size_t bss_nr = 0;
 
+static struct hostapd_chan_event_list *chan_events;
+
 static inline struct hapd_interfaces *get_hapd_interfaces_from_object(struct ubus_object *obj)
 {
 	return container_of(obj, struct hapd_interfaces, ubus);
@@ -709,6 +711,44 @@ static int hostapd_sessions(struct ubus_
 	return 0;
 }
 
+static int hostapd_get_chan_switch_events(struct ubus_context *ctx,
+			struct ubus_object *obj,
+		        struct ubus_request_data *req,
+			const char *method,
+                        struct blob_attr *msg)
+{
+	void *a = NULL;
+	void *t = NULL;
+
+
+	struct hostapd_chan_event_list *entry;
+	blob_buf_init(&b_ev, 0);
+	a = blobmsg_open_table(&b_ev, "chan_switch_event");
+	list_for_each_entry(entry, &chan_events->list, list)
+	{
+		t = blobmsg_open_table(&b_ev, "event");
+		blobmsg_add_u32(&b_ev, "radio_name", entry->records.band);
+		blobmsg_add_u8(&b_ev, "reason", entry->records.reason);
+		blobmsg_add_u64(&b_ev, "timestamp", entry->records.ts.tv_sec * (uint64_t)1000000);
+		blobmsg_add_u32(&b_ev, "frequency", entry->records.freq);
+		blobmsg_close_table(&b_ev, t);
+	}
+
+	blobmsg_close_table(&b_ev, a);
+	ubus_send_reply(ctx, req, b_ev.head);
+	
+	/*delete list*/
+
+	if (!list_empty(&chan_events->list)) {
+	list_for_each_entry(entry, &chan_events->list, list)
+		{
+			list_del(&entry->list);
+		}
+	}
+
+	return 0;
+}
+
 static int
 hostapd_switch_chan(struct ubus_context *ctx, struct ubus_object *obj,
 		    struct ubus_request_data *req, const char *method,
@@ -744,6 +784,9 @@ hostapd_switch_chan(struct ubus_context
 
 	if (hostapd_switch_channel(hapd, &css) != 0)
 		return UBUS_STATUS_NOT_SUPPORTED;
+
+	hostapd_ubus_handle_channel_switch_event(hapd->iface,HOSTAPD_UBUS_HIGH_INTERFERENCE,  css.freq_params.freq);
+
 	return UBUS_STATUS_OK;
 #undef SET_CSA_SETTING
 }
@@ -1333,6 +1376,7 @@ static const struct ubus_method bss_meth
 #ifdef NEED_AP_MLME
 	UBUS_METHOD("switch_chan", hostapd_switch_chan, csa_policy),
 	UBUS_METHOD_NOARG("get_sessions", hostapd_sessions),
+	UBUS_METHOD_NOARG("get_chan_switch_events", hostapd_get_chan_switch_events),
 	UBUS_METHOD_NOARG("clear_sessions", hostapd_clear_sessions),
 	UBUS_METHOD("clear_session", hostapd_clear_session, client_session_del_policy),
 #endif
@@ -1374,6 +1418,7 @@ void hostapd_ubus_add_bss(struct hostapd
 	if (asprintf(&name, "hostapd.%s", hapd->conf->iface) < 0)
 		return;
 
+	INIT_LIST_HEAD(&chan_events->list);
 	avl_init(&hapd->ubus.rt_events, avl_compare_sess_id, false, NULL);
         avl_init(&hapd->ubus.banned, avl_compare_macaddr, false, NULL);
 	obj->name = name;
@@ -1502,6 +1547,24 @@ ubus_event_cb(struct ubus_notify_request
 	ureq->resp = ret;
 }
 
+
+void hostapd_ubus_handle_channel_switch_event(struct hostapd_iface *iface, int reason,
+			       int freq)
+{
+	struct hostapd_chan_event_list *rec = NULL;
+	struct timespec ts;
+	clock_gettime(CLOCK_REALTIME, &ts);
+	rec = os_zalloc(sizeof(struct hostapd_chan_event_list));
+
+	rec->records.reason = reason;
+	rec->records.band = iface->freq;
+	rec->records.ts = ts;
+	rec->records.freq = freq;
+
+	list_add_tail(&rec->list, &chan_events->list);
+
+}
+
 int hostapd_ubus_handle_rt_event(struct hostapd_data *hapd,
 				 struct hostapd_ubus_request *req)
 {
Index: hostapd-2020-06-08-5a8b3662/src/ap/ubus.h
===================================================================
--- hostapd-2020-06-08-5a8b3662.orig/src/ap/ubus.h
+++ hostapd-2020-06-08-5a8b3662/src/ap/ubus.h
@@ -17,9 +17,15 @@ enum hostapd_ubus_event_type {
 	HOSTAPD_UBUS_DEAUTH_REQ,
 	HOSTAPD_UBUS_FDATA_REQ,
 	HOSTAPD_UBUS_IP_REQ,
+	HOSTAPD_UBUS_CHAN_SWITCH,
 	HOSTAPD_UBUS_TYPE_MAX
 };
 
+enum hostapd_ubus_chan_event_reason {
+	HOSTAPD_UBUS_HIGH_INTERFERENCE,
+	HOSTAPD_UBUS_DFS_SWITCH
+};
+
 struct hostapd_ubus_request {
 	enum hostapd_ubus_event_type type;
 	const struct ieee80211_mgmt *mgmt_frame;
@@ -40,6 +46,7 @@ struct rrm_measurement_beacon_report;
 
 #include <libubox/avl.h>
 #include <libubus.h>
+#include <libubox/list.h>
 
 struct hostapd_ubus_bss {
 	struct ubus_object obj;
@@ -121,11 +128,24 @@ struct hostapd_event_avl_rec {
 	struct avl_node avl;
 };
 
+struct channel_switch_event {
+	int band; /* Radio name*/
+	uint8_t reason;
+	struct timespec ts;
+	uint32_t freq;
+};
+
+struct hostapd_chan_event_list {
+	struct channel_switch_event records;
+	struct list_head list;
+};
+
 void hostapd_ubus_add_iface(struct hostapd_iface *iface);
 void hostapd_ubus_free_iface(struct hostapd_iface *iface);
 void hostapd_ubus_add_bss(struct hostapd_data *hapd);
 void hostapd_ubus_free_bss(struct hostapd_data *hapd);
-
+void hostapd_ubus_handle_channel_switch_event(struct hostapd_iface *iface, int reason,
+			       int channel);
 int hostapd_ubus_handle_event(struct hostapd_data *hapd, struct hostapd_ubus_request *req);
 int hostapd_ubus_handle_rt_event(struct hostapd_data *hapd, struct hostapd_ubus_request *req);
 void hostapd_ubus_notify(struct hostapd_data *hapd, const char *type, const u8 *mac);
